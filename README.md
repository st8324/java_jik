# 변수와 타입

### 목표

* **필요한** 변수를 선언할 수 있다.



* 변수 : 타입이 기본타입으로 된 변수. 값을 저장
* 참조변수 : 타입이 클래스,배열, 인터페이스등으로 된 변수. 주소를 저장
* 모든 변수는 변수 또는 참조변수로 구분할 수 있다
* 필드 : 클래스의 멤버 변수/참조변수
* 정적 필드(클래스 멤버변수) : 필드에 static이 붙으면
* 인스턴스 필드(객체 멤버변수) : 필드에 static이 없으면
* 지역 변수 : 메소드 안에 선언되 모든 변수들
* 매개 변수 : 메소드를 실행하기 위해 필요한 변수들. 메소드명 옆에 ()안에 들어감.



* 리터럴 상수 : 변수값을 초기화 하거나 비교할 때 사용하는 값들. 1,2, 'a', 1.23 "안녕"
- 상수 : final이 붙은 변수와 초기값



- 변수 선택(이름이 같은 변수)
  - 필드 vs 매개변수 => 매개변수, 필드를 선택하려면 this를 붙여서 접근
  - 필드 vs 지역변수 => 지역변수
  - 매개변수 vs 지역변수 => 에러 발생 => 변수 중복 선언



- 변수 선언 방법

```java
타입 변수명;
타입 변수명 = 초기값;
타입 변수명1, 변수명2;
```



- 변수명 작성 방법
  - 규칙
    - 숫자가 첫글자로 올 수 없다
    - 특수문자는 _와 $만 가능(공백 불가능)
    - 중복 선언 x
    - 대소문자를 구별
  - 관례
    - 카멜 표기법 : 변수명이 여러 영어 단어로 되어 있는 경우 두번째 단어부터 첫글자만 대문자로
    - 변수명은 의미 있게 지어라



* 기본 타입
  * 정수형
    * byte, short, int, long
    * char : 문자
  * 실수형
    * float : 소수점 6자리까지
    * double : 소수점 15자리까지
  * 논리형
    * boolean : true / false



* 기본 타입변환
  * 자동 타입변환
    * 정수 -> 실수
    * 작은 바이트 -> 큰 바이트
  * 강제(명시적) 타입변환
    * 자동 타입변환이 안될 때
    * 자동 타입변환이 되지만 **필요**에 의해서 강제 타입변환을 활용 : **나누기**



# 연산자

### 목표

* 연산자 종류르 알고 결과를 계산할 수 있다.



* 증감연산자
  * 변수 값이 1증가
  * 잘 쓰면 두줄을 한줄로 줄일 수 있는 경우가 발생
  * ++, --
  * 전위형
    * ++변수명, --변수명
    * 증가/감소 후 동작
    * 증가/감소된 변수를 이용하여 활용
  * 후위형
    * 변수명++, 변수명--
    * 동작 후 증가/감소
    * 변수를 활용한 후 변수를 증가/감소



* 대입 연산자
  * =
  * =과 ==를 착각하여 실술 할 수 있다 => 조건문에서 많이 실수
  * 오른쪽의 값을 왼쪽에 저장(덮어쓰기)



* 산술연산자
  * +, -, *, /, %
  * 정수 산술연산자 정수 => 정수
    * /를 할 때 둘 중 하나 이상에 기본 타입변환을 해야 함.
    * a / (double)b
    * /, %에서 0으로 나눌 수 없다=>ArithmeticException 발생



* 비교 연산자

  * 크기 비교

  * `<, >, <=, >=, ==, != `

  * 결과값이 true 아니면 false => 조건식

  * 문자열(참조변수)은 기본 타입이 아니기 때문에 ==로 비교하면 정확한 결과를 얻을 수 없다

    ```java
    //String을 ==로 해도 되는 경우
    public static void main(String[]args){
        String str1 = "Hello";
        String str2 = "Hello";
        //같은 리터럴 문자열로 된 두 String은 같은 객체를 공유
        if(str1 == str2){
            System.out.println("두 문자열은 같은 객체 참조");
        }else{
            System.out.println("두 문자열은 다른 객체 참조");
        }
    }
    ```



* 논리 연산자

  * &&, ||, !

  * &&

    * ~하고, ~이고
    * 둘다 참이면 참, 하나라도 거짓이면 거짓

  * ||

    * ~이거나, ~하거나
    * 둘다 거짓이면 거짓, 하나라도 참이면 참

  * !

    * ~ 아닌
    * 참이면 거짓, 거짓이면 참

  * 결과값이 true 또는 false => 조건식

  * &&, || 는 단축 평가값(SCE: Short Circuit Evaluation)을 통해서 상황에 따라 한쪽만 체크할 수 있다

    * A && B에서 A가 거짓이면 B는 볼 필요 없이 거짓이므로 B 체크를 건너뜀
    * A || B에서 A가 참이면 B는 볼 필요 없이 참이므로 B 체크를 건너뜀

    ```java
    public static void main(String[]args){
        String str1 = null, str2 = "Hello";
        printEquals(str, str2);
    }
    
    public static void printEqaul(String str1, String str2){
        //main에서 str1에 null을 넣었을 때, str1이 null이고, SCE로 인해 뒤를 확인하지 않아서 문제없이 결과가 출력된다.
        //만약, SCE가 동작하지 않는다면 str1.equals(str2)에서 null.equals(str2)를 한것이기 때문에 NullPointerException이 발생할 수 있다. 하지만 실제는 SEC가 동작해서 발생하지 않음
        if(str1 != null && str1.equals(str2)){
            System.out.println("두 문자열은 같습니다.");
        }else{
            System.out.println("문자열에 null이 있거나, 두 문자열은 다릅니다.");
        }
    }
    ```



* 조건 선택 연산자
  * (조건식) ? 참 : 거짓
  * if문으로 대체 가능하지만 상황에 따라 잘 쓰면 코드의 길이를 줄일 수 있다. => 알면 편함
  * 몰라도 코딩하는데는 크게 문제가 없다.



* 결합 연산자
  * +=, -=, ....
  * A = A 연산자 B; => A 연산자= B;
  * 몰라도 코딩하는데 크게 문제가 없다.
  * 알면 편함.



* 연산자 우선순위
  * 연산자 우선순위가 헷갈리면 ()를 적극적으로 활용
  * 1 + (2 x 3)



# 조건문

### 목표

* 조건에 따라 결과가 달라지는 상황이 있을 때 조건문을 사용하여 해결할 수 있다.



* 모든 조건문은 if문으로 해결 가능. switch는 일부만 가능.
* ~면 ...한다 => 조건문
  * ~ : 조건식
  * ...: 실행문



#### if문

```java
//조건식1이 참이면 실행문1을 실행하고, 조건식1이 거짓이고 조건식2가 참이면 실행문2를 실행하고, 조건식1,2가 모두 거짓이면 실행문3을 실행해라.
if(조건식1){
    실행문1;
}else if(조건식2){
    실행문2;
}else{
    실행문3;
}
```

* if는 필수
* else if는 선택, 여러개 올 수 있다.
* else는 선택, 1개 올 수 있다. else에는 조건식을 쓸 수 없다
* 실행문이 1줄이면 {}를 생략할 수 있다.
* 조건식
  * 결과가 참 또는 거짓으로 판별할 수 있는 식



### switch문

```java
swtich(변수명){
case 값1:
    실행문1;
    break;
case 값2:
    실행문2;
    break;
default:
    실행문3;
}
```

* case에는 상수만 올 수 있다

* 값에는 문자 ,정수, 문자열이 올 수 있다

* break를 통해 실행문을 제어할 수 있다

  * 달의 마지막 일 출력 예제

* swich문에서 break는 switch문을 빠져 나가는 역할

* 여러개의 값이 하나의 실행문으로 처리되는 경우 

  * ```java
    case 값1, 값2, 값3:
    	실행문;
    	break;
    ```

  * ```java
    case 값1, case 값2, case 값3:
    	실행문;
    	break;
    ```



#### 이중(중첩) 조건문

* 조건문 안에 실행문으로 조건문이 또 오는 경우



# 반복문

### 목표

* 규칙적인 작업을 반복적으로 할 때 반복문을 이용할 수 있다.



* 반복문은 언제 사용?
  * 규칙적인 작업을 반복적으로 할 때 반복문을 사용



### for문

```java
for(초기화; 조건식; 증감식){
	실행문;
}
```

* 초기화 
  * 조건식 또는 실행문에서 사용하는 변수를 초기화
  * 변수 선언도 가능
  * 생략 가능
* 조건식
  * 반복문이 계속 실행될지를 판변하는 곳으로 참이면 반복문 실행, 거짓이면 반복문 종료
  * 생략 가능. 생략하면 무조건 참
* 증감식
  * 조건식에서 사용하는 변수를 증가 또는 감소시킴
  * 생략 가능
* 반복횟수 
  * 초기화 + 조건식 + 증감식을 이용하여 반복횟수를 결정
* 규칙적인 작업
  * 실행문
* 향상된 for문
  * 배열 또는 컬렉션(List, Set)을 이용할 때 사용 가능
  * 전체 탐색하는 경우 사용
  * 기본 타입 배열 경우 수정하려면 추가 작업을 해야 함. => 이런 경우는 향상된 for문을 이용 안하는 게 좋음
  * 향상된 for문 이용시 null 체크 해주어야 함

```java
for(타입 변수명 : 배열 또는 컬렉션){
    
}
```



### while문

```java
//while문 시작전에 초기화를 하면 됨
while(조건식){
    실행문;//실행문에 증감식이 같이 있을 수 있다
}
```

* 조건식이 거짓이면 반복문 종료





### do while문

```java
do{
    실행문;
}while(조건식);
```

* 무조건 실행문 1번은 실행
* 조건식이 거짓이면 반복문 종료



* 조건문과 반복문을 모르면 코딩을 못함.
* 강사는
  * 반복횟수가 정해져 있고, 순차적으로 작업하는 경우 for문을 이용
  * 반복횟수가 정해져 있지 않고 특정 상황을 만족할 때 종료하는 경우 while문 이용
  * 무조건 1번이상 실행해야 하는 경우 do while문 이요
    * do while문은 콘솔 프로그램을 제외한 경우 잘 사용하지 않음



### 이중(중첩) 반복문

* 반복문의 실행문으로 반복문이 오는 경우
* 중첩이 늘 수록 반복 횟수가 많이 늘어난다.
  * 밖 반복문이 1000번 실행, 안 반복문이 1000번 실행
    * 1000*1000번 실행



### break

* switch 또는 반복문을 빠져 나오는 역할

* break 반복문명;을 통해 특정 반복문을 빠져 나올 수 있다. 하지만 비추

  ```java
  label: for( ; ; ){
  	for(; ; ){
  		break label;
  	}
  }
  ```



### continue

* skip처럼 특정 위치로 이동
* for문에서는 증감식 위치로, while문, do while문에서는 조건식으로 이동



# 참조 타입

* 주소를 저장하는 타입
* 클래스의 객체, 배열, 인터페이스의 객체 등
* 참조변수는 초기값으 null로 초기화
* 참조변수 값이 null일 때 참조변수에 있는 필드/멤버 메소드를 호출하면 NullPointerException
  * 참조 변수에 있는 필드/멤버 메소드에 접근할 때 null 체크를 해야함
* 참조 변수는 스택 메모리에 생성, 참조 변수와 연결된 객체는 힙 메모리에 생성
* 스택 메모리는 메소드 종료 후 자동으로 제거
* 힙 메모리는 gc(garbage collection)이 실행 될 때 사용하지 않은 객체들은 제거



# 배열

### 목표

* 반복문을 이용하여 배열을 활용할 수 있다.



* (같은 의미 +) 같은 타입의 변수들을 모아 놓은 것
  * 한 배열에 국어 성적만 있는 것이 좋다
  * 한 배열에 국어, 영어, 수학 성적들이 섞여 있으면 어디부터 어디까지가 국어이고, 영어이고, 수학인지를 기억해야하는 불편함이 있어서 비추
* 배열은 참조 변수
* 배열의 이름은 실제 배열(객체)이 있는 곳의 주소를 의미
* 배열의 시작 주소는 0번지
* 배열의 마지막 주소는 배열크기 - 1번지
* 배열 선언 방법

```java
//가장 일반적인 배열 선언 방법
타입 배열명[] = new 타입[개수];
//테스트할 때 초기값을 넣어 활용하는 방법
타입 []배열명= {값1, 값2, ..., 값n};
```

* 배열의 길이
  * 배열명.length
  * 이 때 배열이 null인 체크
* 배열은 향상된 for문을 활용할 수 있다
* 배열 사용 이유?
  * 여러 변수를 이용하는 대신 하나의 배열을 이용하여 효율적으로 관리할 수 있어서
  * 반복문 사용이 가능해지기 때문



* 배열의 단점 => 컬렉션의 List
  * 배열이 다 차면 크기를 늘리는 작업을 직접 구현해야 함
  * 현재 저장된 개수와 전체 크기를 다르게 관리해야 함
  * 배열과 관련된 기능을 직적 구현해야 함



# 클래스

### 목표

* 하나의 정보를 클래스로 만들 수 있다.
* 클래스의 구성 요소를 이해할 수 있다.
* 객체를 이용하여 원하는 동작을 실행할 수 있다.



* 하나의 정보를 나타내기 위해 모아놓은 변수들과 기능들
  * 회사
    * 회사명, 주소, 사원수
    * 회사 정보 출력
* 클래스의 구성 요소
  * 필드(멤버 변수)
    * 클래스를 나타내는 정보. 값, 수치등과 같은 정보
  * 멤버 메소드
    * 클래스의 기능
    * 주로 필드의 값을 변경하거나 필드를 활용
      * 주로 정적 멤버 메소드는 위 경우가 아닌 경우가 많다
        * Math.random()등과 같은 메소드
  * 생성자
    * 필드를 초기화 하는 곳
    * 생성자 오버로딩
      * 복사 생성자 : 매개변수로 같은 클래스의 객체가 오는 생성자
        * 해당 객체와 필드 값은 같지만 서로 다른 객체를 만들기 위해서 => 공유하지 않기 위해서
  
* 클래스 생성 방법

```java
class 클래스명{
    //필드
    타입 변수명;
    //메소드
    public 리턴타입 메소드명(매개변수){
        실행문;
    }
    //생성자
    public 클래스명(){}
}
```

* 객체 생성 방법

```java
클래스명 객체명 = new 생성자();
```

* 객체는 new를 통해 생성이 되고, 생성자를 통해 필드들을 초기화 한다.



### 메소드

* (하나의) 기능을 하도록 모아놓은 코드
* 메소드를 왜 쓸까요?
  * **재사용을 통해** 코드의 중복을 제거해서 **코드의 길이를 줄일 수 있다**
  * **유지 보수가 쉬워진다**
    * 기능이 문제가 있으면 해당 메소드만 확인하면 됨
* 메소드 선언 및 구현 방법

```java
(접근제한자) (static) 리턴타입 메소드명(타입 변수명1, ...){
    구현;
    (return 값;)
}
```

* 메소드 선언 시 고려사항
  * 매개변수 : 기능을 실행하기 위해 필요한 정보들(필수 정보)
    * 메소드 선언 시 실수 하는 경우
      * 필요한 정보인데 누락(무조건 수정)
      * 불필요한 정보를 추가(무조건 수정할 필요는 없음 => 수정하는게 좋음)
  * 리턴타입 : 기능을 실행한 후 알려주는 정보들의 총칭(타입, 클래스명 등)
    * 리턴타입이 있는 경우 : 어떠한 경우에서도 반드시 return을 해야 함
    * 리턴타입이 없는 경우 : 리턴타입에 void를 쓰고, 필요하면 return;을 쓸수 있다
    * 메소드 선언 시 실수 하는 경우
      * 잘못된 리턴타입을 설정
      * 리턴을 해야한는데 리턴이 필요없다고 설정하는 경우
      * 리턴이 필요없는데 리턴을 하는경우 => 수정하는게 좋음
  * 재사용이 쉽도록 메소드를 선언
* 메소드 오버로딩
  * 동일한 이름의 메소드가 여러개인 경우
  * 매개변수가 달라야함
    * 갯수가 다름
    * 타입이 다름
* 메소드 오버라이딩
  * 부모 클래스에게 상속받은 메소드를 재정의하는 것
  * 부모 메소드와 형태(리턴타입, 메소드명, 매개변수) 가 동일
  * 접근제한자는 좁힐 수 없고, 늘릴 있다
    * public -> private (x)
    * private -> public (o)
    * Object의 clone()는 protected이기 때문에 자식 클래스에서 오버라이딩 할 때 public으로 수정해야 외부에서도 사용할 수 있다

* 매개변수의 개수가 정해져 있지 않을 때
  * 리턴타입 메소드명(타입 변수명1, 타입 ...배열명)
    * 배열명에 해당하는 매개변수들이 배열처럼 사용됨
    * 호출할 때는 메소드명(변수명1, 변수명2, 변수명3) 처럼 변수를 여러개 넣을 수 있고, 변수명2, 변수명3이 배열처럼 사용 됨
  * 메소드 오버로딩한 효과



### 재귀 메소드(Recursive method)

* 메소드의 구현부에 자기 자신을 호출하는 메소드
* 예시
  * 피보나치 수열
    * 1 1 2 3 5 8 13 ...
  * 팩토리얼(!) 
    * 5! = 5 * 4 * 3 * 2 * 1
    * 5! = 5 * 4!
* 반복문을 해결 할 수 있으면 재귀 메소드는 가급적 안쓰는게 좋음
* 재귀 메소드는 잘못 쓰면 stack overflow가 발생



### this

* 생성된 객체(나)의 주소를 저장하고 있는 참조변수
* 주로 메소드나 생성자에서 매개변수의 이름과 필드의 이름이 같은 경우 this를 써서 필드와 매개변수를 구분
* 가끔, 메소드명이 긴 경우 this.을 입력하여 자동완성으로 메소드명을 쉽게 입력할 때 사용



### this()

* 생성된 객체의 생성자로, 이미 구현된 생성자를 호출할 때 사용

* 생성자를 잘못 호출하면 stack overflow가 발생할 수 있다

  

### 접근 제한자

* public : 나 + 같은 패키지 + 자식 클래스 + 외부 클래스
* protected : 나 + 같은 패키지 + 자식 클래스
* default : 나 + 같은 패키지
  * 키워드가 아니라 접근제한자를 생략한 걸 default라고 한다.
* private : 나



### 정적 VS 인스턴스

* static이 붙으면 정적, 안붙으면 인스턴스
* 모든 객체가 같은 값을 가지는 필드에 static을 붙이고, 아니면 static을 생략
* 인스턴스
  * 객체명을 통해 호출
  * 각 객체마다 값이 다름
  * 인스턴스 메소드에 정적 필드/메소드 호출이 가능
* 정적
  * 클래스명을 통해 호출
  * 모든 객체가 같은 값을 공유
  * 정적 메소드에 인스턴스 필드/메소드 호출이 불가능



### final

* 수정할 수 없는
* 변수
  * 변수를 수정할 수 없는 => 상수
* 메소드
  * 메소드를 수정할 수 없는 => 오버로딩 가능(새로운 메소드를 만드는 것), 오버라이딩 불가능(자식 메소드에서 수정이 불가능)
* 클래스
  * 클래스를 수정할 수 없는 => 부모 클래스가 될 수 없음
    * 부모 클래스가 되면 자식 클래스에서 메소드를 오버라이딩하는 경우가 생길 수 있기 때문에
  * 대표적인 final 클래스는 String 클래스, Integer 클래스 등



# 상속

### 목표

* 상속의 개념을 이해하고, 클래스와 인스턴스에 상속을 할 수 있다
* 클래스 타입변환을 이해할 수 있다



* 부모 클래스/인터페이스에게 필드와 메소드, 생성자를 물려 받는 것(인터페이스는 필드, 생성자가 없음)
* 부모에게 물려 받아도 접근 제한자에 따라 사용할 수 없을 수 있다.
  * 접근제한자가 private
  * 접근 제한자가 default이고 부모 클래스의 패키지가 자식 클래스의 패키지와 다른 경우
* 언제 상속?
  * is a 관계가 성립
  * A는 B이다가 성립하면 A : 자식 클래스, B : 부모 클래스
* 포함(상속이 아님)
  * has a 관계가 성립
  * A는 B를 가지고 있다가 성립하면 A 클래스안에 필드로 B 클래스의 객체가 들어감
* 상속은 왜?
  * 코드의 중복을 제거
  * 클래스를 빠르게 만들기 위해
  * 다형성을 통해 객체 관리나 메소드를 편리하게 만들수 있기 때문에
* 상속 방법

```java
class 자식클래스명 extends 부모클래스명{
	//구현;
}
```

* 상속을 받은 자식 클래스는 부모 클래스의 메소드를 오버라이딩 할 수 있다



### 클래스 타입변환

* 조상 클래스와 자식 클래스간에 타입변환을 말함

* 서로 관련 없는 클래스는 클래스 타입변환을 할 수 없다

* 자동

  * 자식 클래스의 객체를 부모 클래스의 객체에 저장하는 경우
  * 무조건 가능

* 강제(명시적) - 조건부

  * 부모 클래스의 객체를 자식 클래스의 객체에 저장하는 경우 조건이 맞으면 가능

  ```java
  class P{}
  class C extends P{}
  
  class Main{
      public void main(String[] args){
          //이 경우는 가능
          P p1 = new C();
          C c1 = (C)p1;
          
          //이 경우는 불가능
          P p2 = new P();
          C c2 = (C)p2;//ClassCastException 예외 발생
      }
  }
  ```



### 다형성

* 클래스 타입변환을 이용
* 객체의 다형성은 부모 클래스의 객체를 이용하여 다양한 자식 클래스의 객체들을 관리
* 매개변수의 다형성은 부모클래스의 객체를 매개변수로 지정하여 자식 클래스의 객체들이 올 수 있게 한 것
  * 메소드 오버로딩을 여러개 만든 것과 같은 효과



### 추상 메소드

* 메소드의 구현부가 없는 메소드
* 구현하는 코드가 없다는 의미가 구현해야하는 {}가 없다는 의미



# 인터페이스

### 목표

* 인터페이스를 생성하고, 구현 클래스 통해 객체를 만들 수 있다



* 상수와 추상 메소드, 디폴트 메소드로 이루어진 것
* 인터페이스로는 객체를 생성할 수 없다
* 인터페이스로 객체를 생성하려면
  * 구현 클래스를 만들고 구현 클래스를 통해 객체를 생성
  * 인터페이스의 구현 클래스 역할을 하는 익명 클래스를 이용하영 객체를 생성
* 인터페이스 선언 방법

```java
interface 인터페이스명{
	//정적 상수
    //추상 메소드
    //디폴트 메소드
}
```

* 구현 클래스 선언 방법

```java
class 클래스명 implements 인터페이스명{
	@Override //Override 어노테이션은 생략 가능
	//추상메소드들을 반드시 오버라이딩
	
	//디폴트 메소드는 필요하면 오버라이딩
}
```



### 인터페이스 타입변환

* 인터페이스를 구현한 구현 클래스의 객체를 인터페이스의 객체로 타입변환할 수 있다

```java
interface I {}
class IC implements I{}

class Main{
    public static void main(String[]args){
        I i = new IC();
    }
}
```



### 디폴트 메소드

* 인터페이스에 새로운 추상 메소드 추가시, 해당 인터페이스를 구현한 구현 클래스를 만들어 사용하던 개발자들은 새로운 추상 메소드를 반드시 오버라이딩 해야하기 때문에 잘되던 프로그램이 문제가 될 수 있다.
* 이를 해결하기 위해 디폴트 메소드가 나옴
* 인터페이스에서 메소드는 구현부가 있으면 안되지만, 디폴트 메소드는 존재 가능
  * 메소드를 구현하고, 메소드 앞에 default를 붙이면 디폴트 메소드가 됨
* 디폴트 메소드 선언 방법

```java
interface 인터페이스명{
	public default 리턴타입 메소드명(매개변수들){
		구현;
	}
}
```



### 인터페이스 상속 VS 클래스 상속

* 인터페이스는 부모가 여러개 올 수 있다
* 클래스는 부모가 1개만 올 수 있다



# 예외처리

### 목표

* 예외가 발생할 수 있는 상황을 알고, 예외처리를 할 수 있다



* 예외 : 코드 수정으로 해결 가능한 문제들
* 예외
  * 실행 시 예외(RuntimeException)
    * 실행을 해야 예외를 알 수 있는 예외들
    * 예외처리를 안해도 에러가 발생하지 않음
    * 사용자의 실수로 발생할 수 있는 예외
      * Scanner를 이용하여 콘솔에서 입력받아 처리하는 경우
        * 정수를 입력해야하는데 문자를 입력하는 경우
    * 개발자의 실수로 발생할 수 있는 예외
      * 배열의 잘못된 번지를 접근하려는 경우
      * 참조변수가 null인데 접근하려는 경우
  * 실행 시 예외가 아닌 예외
    * 컴파일 단계에서 예외를 체크하는 예외들
    * 런타임 예외가 아닌 예외들 모두
    * 예외처리를 안하면 에러가 발생
* 예외처리 방법
  * 여러개의 catch 이용 시 조상 예외 클래스가 위로 올라가면 안됨
  * finally는 생략 가능
  * 누가 시킨 일을 내가 하다 문제가 발생했을 때, 내가 직접 처리

```java
try{
    //예외가 발생할 수 있는 코드들
}catch(예외클래스명1 e){
    //예외처리
}catch(예외클래스명2 e){
    //예외처리
}finally{
    //무조건 실행되는 코드로, 메소드가 try또는 catch에서 종료되는 경우 finally 아래 코드는 실행되지 않지만 finally 코드는 무조건 실행
}
```

* 예외 넘기기
  * throw를 이용하여 예외를 넘길 수 있다
  * throw를 통해 넘기는 예외가 런타임 예외가 아니면 thorws를 이용하여 예외 클래스명을 적어줘야 한다
  * 메소드를 호출한 메소드에게 예외를 넘겨서 처리하는 방법
  * 누가 시킨 일을 내가 하다 문제가 발생했을 때, 일을 시킨 사람에게 어떤 문제가 발생했는지 알려주고 알아서 처리하라고 함



# 제네릭

### 목표

* 제네릭을 왜 사용하지와 어떻게 사용하지를 알 수 있다



* 제네릭 클래스를 사용하는 이유
  * 상황에 따라 클래스의 필드 타입을 바꿔야 할 때
* 제네릭 클래스 사용방법
  * 클래스명에는 제네릭 클래스에서 필요한 제네릭 타입 개수만큼 입력

```java
제네릭클래스명<클래스명>객체명 = new 제네릭클래스명<클래스명>();
```

* 제네릭 클래스에 기본 타입을 넣을 수 없다
  * Wrapper 클래스를 이용하여 넣을 수 있다



# 컬렉션 프레임워크

### 목표

* 컬렉션프레임워크의 종류를 알고 활용할 수 있다



* 컬렉션프레임워크를 이용한 클래스들은 제네릭 클래스이다
* 수집된 데이터를 관리하는 방법
* 컬렉션프레임워크는 컬렉션과 Map으로 구성
* 컬렉션은 List, Set으로 구성



### List

* 순서를 보장, 중복 가능



### Set

* 순서를 보장 X, 중복 불가능



### Map

* key와 value로 이루어져 있다
* key는 중복 불가능, value는 중복 가능
* 순서를 보장 X



### 반복문 활용

* 컬렉션(List, Set)은 향상된 for문을 이용하여 접근할 수 있다.
* 컬렉션(List, Set)은 Iterator와 반복문을 이용하여 접근할 수 있다.
* Map은 반복문을 이용하여 직접 접근할 수 없다
  * entrySet()을 이용
  * KeySet()을 이용





# 람다식

### 목표

* 람다식을 활용할수 있다



* 메소드를 간단하게 표현하도록 한 식
* 조건
  * 인터페이스를 구현한 객체가 필요한 경우
  * 인터페이스의 추상 메소드가 1개인 경우
* 위 조건을 만족할 때 익명 클래스의 객체를 생성을 람다식으로 할 수 있다
  * 이 때, new를 사용하지 않음
* 람다식 사용 예

```java
interface Hello{
    public void printHello();
}
class Main{
    public static void main(String[]args){
        Hello hello = ()->System.out.println("Hello");
    }
}
```

* 람다식을 위한 인터페이스들을 활용
  * Consumer, Supplier, Function, Operator, Predicate 인터페이스를 활용하면 람다식 적용을 위해 인터페이스를 만들 필요가 없음
    * 주로 Function, Predicate를 메소드의 매개변수로 넣어 필터링을 할 때 사용

















