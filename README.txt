# 변수와 타입

### 목표

* **필요한** 변수를 선언할 수 있다.



* 변수 : 타입이 기본타입으로 된 변수. 값을 저장
* 참조변수 : 타입이 클래스,배열, 인터페이스등으로 된 변수. 주소를 저장
* 모든 변수는 변수 또는 참조변수로 구분할 수 있다
* 필드 : 클래스의 멤버 변수/참조변수
* 정적 필드(클래스 멤버변수) : 필드에 static이 붙으면
* 인스턴스 필드(객체 멤버변수) : 필드에 static이 없으면
* 지역 변수 : 메소드 안에 선언되 모든 변수들
* 매개 변수 : 메소드를 실행하기 위해 필요한 변수들. 메소드명 옆에 ()안에 들어감.



* 리터럴 상수 : 변수값을 초기화 하거나 비교할 때 사용하는 값들. 1,2, 'a', 1.23 "안녕"
- 상수 : final이 붙은 변수와 초기값



- 변수 선택(이름이 같은 변수)
  - 필드 vs 매개변수 => 매개변수, 필드를 선택하려면 this를 붙여서 접근
  - 필드 vs 지역변수 => 지역변수
  - 매개변수 vs 지역변수 => 에러 발생 => 변수 중복 선언



- 변수 선언 방법

```java
타입 변수명;
타입 변수명 = 초기값;
타입 변수명1, 변수명2;
```



- 변수명 작성 방법
  - 규칙
    - 숫자가 첫글자로 올 수 없다
    - 특수문자는 _와 $만 가능(공백 불가능)
    - 중복 선언 x
    - 대소문자를 구별
  - 관례
    - 카멜 표기법 : 변수명이 여러 영어 단어로 되어 있는 경우 두번째 단어부터 첫글자만 대문자로
    - 변수명은 의미 있게 지어라



* 기본 타입
  * 정수형
    * byte, short, int, long
    * char : 문자
  * 실수형
    * float : 소수점 6자리까지
    * double : 소수점 15자리까지
  * 논리형
    * boolean : true / false



* 기본 타입변환
  * 자동 타입변환
    * 정수 -> 실수
    * 작은 바이트 -> 큰 바이트
  * 강제(명시적) 타입변환
    * 자동 타입변환이 안될 때
    * 자동 타입변환이 되지만 **필요**에 의해서 강제 타입변환을 활용 : **나누기**



# 연산자

### 목표

* 연산자 종류르 알고 결과를 계산할 수 있다.



* 증감연산자
  * 변수 값이 1증가
  * 잘 쓰면 두줄을 한줄로 줄일 수 있는 경우가 발생
  * ++, --
  * 전위형
    * ++변수명, --변수명
    * 증가/감소 후 동작
    * 증가/감소된 변수를 이용하여 활용
  * 후위형
    * 변수명++, 변수명--
    * 동작 후 증가/감소
    * 변수를 활용한 후 변수를 증가/감소



* 대입 연산자
  * =
  * =과 ==를 착각하여 실술 할 수 있다 => 조건문에서 많이 실수
  * 오른쪽의 값을 왼쪽에 저장(덮어쓰기)



* 산술연산자
  * +, -, *, /, %
  * 정수 산술연산자 정수 => 정수
    * /를 할 때 둘 중 하나 이상에 기본 타입변환을 해야 함.
    * a / (double)b
    * /, %에서 0으로 나눌 수 없다=>ArithmeticException 발생



* 비교 연산자

  * 크기 비교

  * `<, >, <=, >=, ==, != `

  * 결과값이 true 아니면 false => 조건식

  * 문자열(참조변수)은 기본 타입이 아니기 때문에 ==로 비교하면 정확한 결과를 얻을 수 없다

    ```java
    //String을 ==로 해도 되는 경우
    public static void main(String[]args){
        String str1 = "Hello";
        String str2 = "Hello";
        //같은 리터럴 문자열로 된 두 String은 같은 객체를 공유
        if(str1 == str2){
            System.out.println("두 문자열은 같은 객체 참조");
        }else{
            System.out.println("두 문자열은 다른 객체 참조");
        }
    }
    ```



* 논리 연산자

  * &&, ||, !

  * &&

    * ~하고, ~이고
    * 둘다 참이면 참, 하나라도 거짓이면 거짓

  * ||

    * ~이거나, ~하거나
    * 둘다 거짓이면 거짓, 하나라도 참이면 참

  * !

    * ~ 아닌
    * 참이면 거짓, 거짓이면 참

  * 결과값이 true 또는 false => 조건식

  * &&, || 는 단축 평가값(SCE: Short Circuit Evaluation)을 통해서 상황에 따라 한쪽만 체크할 수 있다

    * A && B에서 A가 거짓이면 B는 볼 필요 없이 거짓이므로 B 체크를 건너뜀
    * A || B에서 A가 참이면 B는 볼 필요 없이 참이므로 B 체크를 건너뜀

    ```java
    public static void main(String[]args){
        String str1 = null, str2 = "Hello";
        printEquals(str, str2);
    }
    
    public static void printEqaul(String str1, String str2){
        //main에서 str1에 null을 넣었을 때, str1이 null이고, SCE로 인해 뒤를 확인하지 않아서 문제없이 결과가 출력된다.
        //만약, SCE가 동작하지 않는다면 str1.equals(str2)에서 null.equals(str2)를 한것이기 때문에 NullPointerException이 발생할 수 있다. 하지만 실제는 SEC가 동작해서 발생하지 않음
        if(str1 != null && str1.equals(str2)){
            System.out.println("두 문자열은 같습니다.");
        }else{
            System.out.println("문자열에 null이 있거나, 두 문자열은 다릅니다.");
        }
    }
    ```



* 조건 선택 연산자
  * (조건식) ? 참 : 거짓
  * if문으로 대체 가능하지만 상황에 따라 잘 쓰면 코드의 길이를 줄일 수 있다. => 알면 편함
  * 몰라도 코딩하는데는 크게 문제가 없다.



* 결합 연산자
  * +=, -=, ....
  * A = A 연산자 B; => A 연산자= B;
  * 몰라도 코딩하는데 크게 문제가 없다.
  * 알면 편함.



* 연산자 우선순위
  * 연산자 우선순위가 헷갈리면 ()를 적극적으로 활용
  * 1 + (2 x 3)



# 조건문

### 목표

* 조건에 따라 결과가 달라지는 상황이 있을 때 조건문을 사용하여 해결할 수 있다.



* 모든 조건문은 if문으로 해결 가능. switch는 일부만 가능.
* ~면 ...한다 => 조건문
  * ~ : 조건식
  * ...: 실행문



#### if문

```java
//조건식1이 참이면 실행문1을 실행하고, 조건식1이 거짓이고 조건식2가 참이면 실행문2를 실행하고, 조건식1,2가 모두 거짓이면 실행문3을 실행해라.
if(조건식1){
    실행문1;
}else if(조건식2){
    실행문2;
}else{
    실행문3;
}
```

* if는 필수
* else if는 선택, 여러개 올 수 있다.
* else는 선택, 1개 올 수 있다. else에는 조건식을 쓸 수 없다
* 실행문이 1줄이면 {}를 생략할 수 있다.
* 조건식
  * 결과가 참 또는 거짓으로 판별할 수 있는 식



### switch문

```java
swtich(변수명){
case 값1:
    실행문1;
    break;
case 값2:
    실행문2;
    break;
default:
    실행문3;
}
```

* case에는 상수만 올 수 있다

* 값에는 문자 ,정수, 문자열이 올 수 있다

* break를 통해 실행문을 제어할 수 있다

  * 달의 마지막 일 출력 예제

* swich문에서 break는 switch문을 빠져 나가는 역할

* 여러개의 값이 하나의 실행문으로 처리되는 경우 

  * ```java
    case 값1, 값2, 값3:
    	실행문;
    	break;
    ```

  * ```java
    case 값1, case 값2, case 값3:
    	실행문;
    	break;
    ```



#### 이중(중첩) 조건문

* 조건문 안에 실행문으로 조건문이 또 오는 경우



# 반복문

### 목표

* 규칙적인 작업을 반복적으로 할 때 반복문을 이용할 수 있다.



* 반복문은 언제 사용?
  * 규칙적인 작업을 반복적으로 할 때 반복문을 사용



### for문

```java
for(초기화; 조건식; 증감식){
	실행문;
}
```

* 초기화 
  * 조건식 또는 실행문에서 사용하는 변수를 초기화
  * 변수 선언도 가능
  * 생략 가능
* 조건식
  * 반복문이 계속 실행될지를 판변하는 곳으로 참이면 반복문 실행, 거짓이면 반복문 종료
  * 생략 가능. 생략하면 무조건 참
* 증감식
  * 조건식에서 사용하는 변수를 증가 또는 감소시킴
  * 생략 가능
* 반복횟수 
  * 초기화 + 조건식 + 증감식을 이용하여 반복횟수를 결정
* 규칙적인 작업
  * 실행문
* 향상된 for문
  * 배열 또는 컬렉션(List, Set)을 이용할 때 사용 가능
  * 전체 탐색하는 경우 사용
  * 기본 타입 배열 경우 수정하려면 추가 작업을 해야 함. => 이런 경우는 향상된 for문을 이용 안하는 게 좋음
  * 향상된 for문 이용시 null 체크 해주어야 함

```java
for(타입 변수명 : 배열 또는 컬렉션){
    
}
```



### while문

```java
//while문 시작전에 초기화를 하면 됨
while(조건식){
    실행문;//실행문에 증감식이 같이 있을 수 있다
}
```

* 조건식이 거짓이면 반복문 종료





### do while문

```java
do{
    실행문;
}while(조건식);
```

* 무조건 실행문 1번은 실행
* 조건식이 거짓이면 반복문 종료



* 조건문과 반복문을 모르면 코딩을 못함.
* 강사는
  * 반복횟수가 정해져 있고, 순차적으로 작업하는 경우 for문을 이용
  * 반복횟수가 정해져 있지 않고 특정 상황을 만족할 때 종료하는 경우 while문 이용
  * 무조건 1번이상 실행해야 하는 경우 do while문 이요
    * do while문은 콘솔 프로그램을 제외한 경우 잘 사용하지 않음



### 이중(중첩) 반복문

* 반복문의 실행문으로 반복문이 오는 경우
* 중첩이 늘 수록 반복 횟수가 많이 늘어난다.
  * 밖 반복문이 1000번 실행, 안 반복문이 1000번 실행
    * 1000*1000번 실행



### break

* switch 또는 반복문을 빠져 나오는 역할

* break 반복문명;을 통해 특정 반복문을 빠져 나올 수 있다. 하지만 비추

  ```java
  label: for( ; ; ){
  	for(; ; ){
  		break label;
  	}
  }
  ```



### continue

* skip처럼 특정 위치로 이동
* for문에서는 증감식 위치로, while문, do while문에서는 조건식으로 이동



# 참조 타입

* 주소를 저장하는 타입
* 클래스의 객체, 배열, 인터페이스의 객체 등
* 참조변수는 초기값으 null로 초기화
* 참조변수 값이 null일 때 참조변수에 있는 필드/멤버 메소드를 호출하면 NullPointerException
  * 참조 변수에 있는 필드/멤버 메소드에 접근할 때 null 체크를 해야함
* 참조 변수는 스택 메모리에 생성, 참조 변수와 연결된 객체는 힙 메모리에 생성
* 스택 메모리는 메소드 종료 후 자동으로 제거
* 힙 메모리는 gc(garbage collection)이 실행 될 때 사용하지 않은 객체들은 제거



# 배열

### 목표

* 반복문을 이용하여 배열을 활용할 수 있다.



* (같은 의미 +) 같은 타입의 변수들을 모아 놓은 것
  * 한 배열에 국어 성적만 있는 것이 좋다
  * 한 배열에 국어, 영어, 수학 성적들이 섞여 있으면 어디부터 어디까지가 국어이고, 영어이고, 수학인지를 기억해야하는 불편함이 있어서 비추
* 배열은 참조 변수
* 배열의 이름은 실제 배열(객체)이 있는 곳의 주소를 의미
* 배열의 시작 주소는 0번지
* 배열의 마지막 주소는 배열크기 - 1번지
* 배열 선언 방법

```java
//가장 일반적인 배열 선언 방법
타입 배열명[] = new 타입[개수];
//테스트할 때 초기값을 넣어 활용하는 방법
타입 []배열명= {값1, 값2, ..., 값n};
```

* 배열의 길이
  * 배열명.length
  * 이 때 배열이 null인 체크
* 배열은 향상된 for문을 활용할 수 있다
* 배열 사용 이유?
  * 여러 변수를 이용하는 대신 하나의 배열을 이용하여 효율적으로 관리할 수 있어서
  * 반복문 사용이 가능해지기 때문



* 배열의 단점 => 컬렉션의 List
  * 배열이 다 차면 크기를 늘리는 작업을 직접 구현해야 함
  * 현재 저장된 개수와 전체 크기를 다르게 관리해야 함
  * 배열과 관련된 기능을 직적 구현해야 함



# 클래스

### 목표

* 하나의 정보를 클래스로 만들 수 있다.
* 클래스의 구성 요소를 이해할 수 있다.
* 객체를 이용하여 원하는 동작을 실행할 수 있다.



* 하나의 정보를 나타내기 위해 모아놓은 변수들과 기능들
  * 회사
    * 회사명, 주소, 사원수
    * 회사 정보 출력
* 클래스의 구성 요소
  * 필드(멤버 변수)
    * 클래스를 나타내는 정보, 값, 수치등과 같은 정보
  * 멤버 메소드
    * 클래스의 기능
    * 주로 필드의 값을 변경하거나 필드를 활용
      * 주로 정적 멤버 메소드는 위 경우가 아닌 경우가 많다
        * Math.random()등과 같은 메소드
  * 생성자
    * 필드를 초기화 하는 곳

* 클래스 생성 방법

```java
class 클래스명{
    //필드
    타입 변수명;
    //메소드
    public 리턴타입 메소드명(매개변수){
        실행문;
    }
    //생성자
    public 클래스명(){}
}
```

* 객체 생성 방법

```java
클래스명 객체명 = new 생성자();
```

* 객체는 new를 통해 생성이 되고, 생성자를 통해 필드들을 초기화 한다.





